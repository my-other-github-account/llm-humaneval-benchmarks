{"task_id": "HumanEval/0", "completion": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    result = []\n    for char in paren_string:\n        if char == \"(\":\n            stack.append((char, len(stack)))\n        elif char == \")\":\n            if not stack or stack[-1][1]!= len(stack):\n                raise ValueError(\"Unbalanced parentheses\")\n            index = len(stack) - 1\n            while index >= 0 and stack[index][1] <= len(stack):\n                if stack[index][1] == len(stack) - 1:\n                    break\n                index -= 1\n            else:\n                raise ValueError(\"Unbalanced parentheses\")\n            result.append(paren_string[max(0, index + 1) : min(len(paren_string), index + 2)])\n            del stack[:index+1:]\n        elif char.iswhitespace():\n            # ignore whitespace between parentheses\n            continue\n        else:\n            raise ValueError(\"Unexpected character\", char)\n    if stack:\n        raise ValueError(\"Unclosed parenthesis\")\n    return result"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number):\n    return round(number - int(number))"}
{"task_id": "HumanEval/3", "completion": "def below_zero(operations: List[int]) -> bool:\n    for operation in operations:\n        if operation < 0:\n            return True\n    else:\n        return False"}
{"task_id": "HumanEval/4", "completion": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Calculate Mean Absolute Deviation for a given list of input numbers. \"\"\"\n    if len(numbers) == 0:\n        return None\n    else:\n        avg = sum(numbers) / len(numbers)\n        mad = abs(numbers - [avg] * len(numbers)).mean()\n        return mad"}
{"task_id": "HumanEval/5", "completion": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i == 0 or numbers[i]!= numbers[i - 1]:\n            result.append(numbers[i])\n        else:\n            result.extend([delimeter, numbers[i]])\n    return result"}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string: str) -> List[int]:\n    stack = []\n    result = []\n    for char in paren_string:\n        if char == '(':\n            stack.append((char, len(stack)))\n        elif char == ')':\n            depth = len(stack) - 1\n            if depth >= 0 and stack[-1][1] < depth:\n                result.append(depth + 1)\n            stack.pop(-1)\n    return result"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if len(numbers) == 0:\n        return (0, 1)\n    else:\n        result = numbers[0] * numbers[-1]\n        for i in range(len(numbers)):\n            result += numbers[i]\n        return (result, numbers[-1])"}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_so_far = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far:\n            result.append(max_so_far)\n            max_so_far = numbers[i]\n        else:\n            result.append(max_so_far)\n    \n    return result + [max_so_far]"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string):\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string):\n    \"\"\" find the shortest palindrome that begins with a supplied string.\n        Algorithm idea is simple:\n        1. Find the longest postfix of supplied string that is a palindrome.\n        2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    # Find the longest palindromic postfix of the input string\n    max_len = len(string)\n    for i in range(max_len - 1, -1, -1):\n        if is_palindrome(string[i:]):\n            break\n    \n    # If there is no palindromic postfix, return original string\n    if i >= max_len / 2:\n        return string\n    \n    # Reverse the prefix and append it to the palindromic postfix\n    prefix_len = max_len // 2\n    prefix = string[:prefix_len][::-1]\n    return prefix + string[-prefix_len:]"}
{"task_id": "HumanEval/11", "completion": "def string_xor(a: str, b: str) -> str:\n    # Convert input strings to lists of integers\n    a = list(map(int, a))\n    b = list(map(int, b))\n    \n    # Perform bitwise XOR operation on corresponding elements in the lists\n    result = [a[i] ^ b[i] for i in range(len(a))]\n    \n    # Convert resulting list back to a string\n    return ''.join([str(char) for char in result])"}
{"task_id": "HumanEval/12", "completion": "def longest(strings: List[str]) -> Optional[str]:\n    if len(strings) == 0:\n        return None\n    else:\n        longest_string = ''\n        for string in strings:\n            if len(string) > len(longest_string):\n                longest_string = string\n        return longest_string"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Return a greatest common divisor of two integers a and b\"\"\"\n    while b!= 0:\n        a = a // b\n        b = b % a\n    return a"}
{"task_id": "HumanEval/14", "completion": "def all_prefixes(string: str) -> List[str]:\n    \"\"\"Return list of all prefixes from shortest to longest of the input string\"\"\"\n    return [string] + [string[:i+1] for i in range(len(string))][::-1]"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    return''.join([str(i) for i in range(n+1)])"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string):\n    return len([c.lower() for c in set(string.lower())])"}
{"task_id": "HumanEval/17", "completion": "def parse_music(music_string: str) -> List[int]:\n    music = []\n    for char in music_string:\n        if char == \"o\":\n            music.append(4) # Whole note\n        elif char == \"|\":\n            if len(music) > 0 and music[-1] % 2 == 0:\n                music[-1] //= 2 # Half note\n            else:\n                music.append(2) # Quarter note\n        elif char == \".\":\n            if len(music) > 0 and music[-1]!= 0:\n                music[-1] -= 1 # Beat\n            else:\n                music.append(1) # Beat\n    return music"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    for i in range(len(string)):\n        if substring in string[i:]:\n            count += 1\n    return count"}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    words = numbers.split()\n    words.sort()\n    return''.join(words)"}
{"task_id": "HumanEval/20", "completion": "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    smallest = min(numbers)\n    largest = max(numbers)\n    for num in numbers:\n        if abs(num - smallest) < abs(largest - smallest):\n            smaller = smallest\n            larger = num\n        elif abs(num - largest) < abs(larger - largest):\n            smaller = num\n            larger = largest\n        else:\n            break\n    return smaller, larger"}
{"task_id": "HumanEval/21", "completion": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    scaled_numbers = [(x - min_num) / (max_num - min_num) for x in numbers]\n    return scaled_numbers"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string):\n    return len(string)"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    if n == 0 or n == 1:\n        return 1\n    else:\n        for i in range(2, abs(n)):\n            while n % i == 0:\n                n //= i\n                i -= 1\n        return i + 1"}
{"task_id": "HumanEval/25", "completion": "def factorize(n: int) -> List[int]:\n    \"\"\"Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    \"\"\"\n    if n < 1:\n        return []\n    elif n == 1:\n        return [1]\n    else:\n        # find all divisors and their counts\n        divisors = {}\n        for i in range(2, abs(n)):\n            while n % i == 0:\n                count = len([i for j in range(abs(n/i)) if j*i == j])\n                if i in divisors:\n                    divisors[i] += count\n                else:\n                    divisors[i] = count\n                n //= i\n        # convert divisor counts to a list of tuples representing each factor and its count\n        factors = [(factor, count) for factor, count in sorted(divisors.items())]\n        # remove duplicates by sorting and taking first occurrence of each factor\n        unique_factors = sorted(set([tuple(sorted(factor)) for factor, count in factors]))\n        # flatten list of tuples into a single list of factors\n        flat_factors = [f[0] * f[1] for factor in unique_factors]\n        return flat_factors"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    unique = []\n    for num in numbers:\n        if num not in unique:\n            unique.append(num)\n    return unique"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    return ''.join([char.upper() if char.islower() else char.lower() for char in string])"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)"}
{"task_id": "HumanEval/29", "completion": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [string for string in strings if string.startswith(prefix)]"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    return [num for num in l if num > 0]"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Check for divisibility by integers from 2 to sqrt(n)\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    else:\n        return True"}
{"task_id": "HumanEval/32", "completion": "def poly(xs: list, x: float) -> float:\n    \"\"\"Evaluates polynomial with coefficients xs at point x.\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list) -> float:\n    \"\"\"Finds x such that poly(x) = 0.\"\"\"\n    if len(xs) % 2!= 0 or xs[-1] == 0:\n        raise ValueError(\"List of coefficients must have an even number of elements \"\n                         \"and largest non zero coefficient to guarantee a solution.\")\n    else:\n        return (-sum(math.cbrt(xi / (i + 1)) for i, xi in enumerate(xs[:-1])) /\n                math.sqrt(xs[-1] * math.cbrt(-1))) ** 2"}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    return sorted([l[i] if i % 3!= 0 else sorted(l[:i])[-1] for i in range(len(l))])"}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    return sorted(list(set(l)))"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    return max(l)"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n+1):\n        if i % 11 == 0 or i % 13 == 0 and i < n:\n            count += 1\n    return count"}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    return sorted(zip(*[iter(l)] * 2)[::2], key=lambda x: x[0])"}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # create a list of tuples containing the original and shifted versions of each character\n    shifts = [(ord(c), ord(c)) for c in s]\n    \n    # iterate over the shifts list and apply the appropriate shift to each character\n    result = \"\"\n    for shift in reversed(shifts):\n        char = chr(shift[1] - shift[0])\n        result += char if char.isalpha() else s[shift[0]:shift[1]]\n        \n    return result"}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n: int) -> int:\n    fib = [0, 1]\n    i = 2\n    while len(fib) < n+1:\n        fib.append(fib[-1]+fib[-2])\n    if all([not isinstance(fib[i], int) or isprime(fib[i]) for i in range(len(fib)) if i!= 0 and i!= len(fib)-1]):\n        return fib[n]\n    else:\n        return None"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    It checks whether there exist three distinct elements in the list that\n    sum to zero. If so, it returns true; otherwise, it returns false.\n    \"\"\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n            else:\n                continue\n        else:\n            break\n    else:\n        return False"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    # Initialize variables for counting collisions\n    left_to_right = [False] * n\n    right_to_left = [True] * n\n    \n    # Set up initial positions of cars\n    for i in range(n):\n        if i < n // 2:\n            left_to_right[i] = True\n        else:\n            right_to_left[i - n // 2] = False\n            \n    # Simulate movement of cars until collision occurs or all cars have passed by\n    while len([1 for x in left_to_right + right_to_left if x]) > 0:\n        \n        # Move all cars one unit to the right\n        for i in range(n):\n            if i < n // 2:\n                left_to_right[i] = not left_to_right[i]\n            else:\n                right_to_left[i - n // 2] = not right_to_left[i - n // 2]\n                \n        # Check for collisions\n        num_collisions = 0\n        for i in range(n):\n            if i < n // 2 and not left_to_right[i]:\n                for j in range(i+1, n//2):\n                    if left_to_right[j] == True:\n                        num_collisions += 1\n                        break\n            elif i >= n // 2 and not right_to_left[i-n//2]:\n                for j in range(i-n//2-1, -1, -1):\n                    if right_to_left[j] == true:\n                        num_collisions += 1\n                        break\n                        \n        print(\"After {} units, there were {} collisions.\".format(len(left_to_right), num_collisions))\n        \n        # Stop simulation if all cars have passed by without colliding\n        if len([x for x in left_to_right + right_to_left if x]) == 0:\n            break\n    \n    return num_collisions"}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n    return l + [x+1 for x in l]"}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int) -> str:\n    if base < 10:\n        # convert integer to string\n        s = hex(x)[2:] if x >= 0 else bin(x)[2:]\n        \n        # pad with leading zeros if necessary\n        padded_s = ('0' * (3 - len(s)) + s).zfill()\n        \n        # reverse string and insert commas for readability\n        reversed_padded_s = ','.join([reversed(i) for i in padded_s.split(',')])[::-1]\n        \n        return f\"{int(reversed_padded_s)} in base {base}\"\n    \n    raise ValueError(\"Base must be a positive integer less than 10\")"}
{"task_id": "HumanEval/45", "completion": "def triangle_area(base, height):\n    return 0.5 * base * height"}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int) -> int:\n    if n <= 4:\n        return [0, 0, 2, 0][n]\n    else:\n        prev = [0, 0, 2, 0][3]\n        for i in range(4, n+1):\n            next_prev = prev[i-1] + prev[i-2] + prev[i-3] + prev[i-4]\n            prev[i] = next_prev\n        return prev[-1]"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    sorted_list = sorted(set(l))\n    n = len(sorted_list)\n    if n % 2 == 0:\n        return (sorted_list[n//2 - 1] + sorted_list[n//2]) / 2\n    else:\n        return sorted_list[n//2]"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    \"\"\"\n    return text == text[::-1]"}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int) -> int:\n    return n % p"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n    \ndef decode_shift(s: str):\n    shifted = [chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s]\n    return \"\".join(shifted)"}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    # Define set of vowels\n    vowels = set(['aeiouAEIOU'])\n    \n    # Convert text to lowercase for easier comparison\n    text = text.lower()\n    \n    # Iterate over each character in text\n    new_text = \"\"\n    for char in text:\n        if char not in vowels:\n            new_text += char\n    \n    return new_text"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int) -> bool:\n    return all(x < t for x in l)"}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int) -> int:\n    return x + y"}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str) -> bool:\n    return sorted(s0) == sorted(s1)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    else:\n        a = 0\n        b = 1\n        while len([a]) < n:\n            c = a + b\n            a = b\n            b = c\n        return b - a"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    # count the number of opening and closing brackets\n    open_count = brackets.count('<')\n    close_count = brackets.count('>')\n    \n    # check if there are an equal number of opening and closing brackets\n    if open_count == close_count:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    if len(l) < 2:\n        return True # empty lists and single element lists are considered monotonic by default\n    \n    for i in range(len(l)-1):\n        if l[i] > l[i+1]:\n            return False # if there's a decrease, then it's not monotonic\n    else:\n        return True # if there are no decreases, then it's monotonic"}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1 & l2))"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    if n <= 1 or is_prime(n):\n        return n\n    else:\n        for i in range(2, int(n**0.5)+1):\n            while True:\n                if is_prime(n % i):\n                    n //= i\n                    break\n            else:\n                i += 1\n        return i\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    elif n == 2:\n        return True\n    elif all([not is_prime(i) for i in range(3, int(n**0.5)+1)]):\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    return sum([i for i in range(1, n+1)])"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for char in brackets:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0 and stack[-1] == '(':\n                stack.pop()\n            else:\n                return False\n    return not stack"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs):\n    return [x**i for i in range(len(xs)) if i > 0]"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int) -> int:\n    if n <= 2:\n        return n\n    else:\n        prev_1 = 0\n        prev_2 = 1\n        for i in range(3, n+1):\n            curr = prev_1 + prev_2\n            prev_1 = prev_2\n            prev_2 = curr\n        return prev_2"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] in ['a', 'e', 'i', 'o', 'u'] or ('y' == s[-1]) and i!= len(s)-1:\n            count += 1\n    return count"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    if shift >= len(str(x)):\n        return str(int(x)[::-1])\n    else:\n        return ''.join([chr(ord(c) - (ord('0') + shift)) for c in str(x)])"}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    return sum([ord(c) for c in s if ord(c) >= 64]) # use list comprehension to iterate over each character in the string\n                                                     # check if the character is an uppercase letter using `ord()` and comparison operator\n                                                     # convert the character to its corresponding ASCII code using `ord()` again\n                                                     # add the ASCII code to the running total using the `sum()` function"}
{"task_id": "HumanEval/67", "completion": "def fruit_distribution(s, n):\n    # split the input string into a list of words\n    words = s.split()\n    \n    # count the number of times each word appears in the list\n    num_apples = sum([1 for word in words if \"apple\" in word])\n    num_oranges = sum([1 for word in words if \"orange\" in word])\n    num_mango = sum([1 for word in words if \"mango\" in word])\n    \n    # calculate the total number of fruits in the basket\n    total_fruit = int(num_apples + num_oranges + num_mango)\n    \n    # subtract the number of apples and oranges from the total to get the number of mangoes\n    num_mango = total_fruit - num_apples - num_oranges\n    \n    return num_mango"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    if len(arr) == 0:\n        return []\n    elif sum([1 for x in arr if x % 2 == 0]) > 0:\n        min_even = min(filter(lambda x: x % 2 == 0, arr))\n        min_index = arr.index(min_even)\n        return [min_even, min_index]\n    else:\n        return []"}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n    max_freq = 0\n    result = None\n    for num in lst:\n        if num > 0:\n            freq = lst.count(num)\n            if freq >= max_freq or max_freq is None:\n                max_freq = freq\n                result = num\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    sorted_lst = sorted(set(lst)) # remove duplicates and sort normally\n    if len(sorted_lst) > 0:\n        min_val = sorted_lst[0]\n        max_val = sorted_lst[-1]\n        middle_lst = sorted_lst[1:-1]\n        result = [min_val] + [max_val] * (len(middle_lst) // 2) + middle_lst\n        for i in range(len(result)):\n            if i < len(result) - 1 and result[i]!= result[i+1]:\n                result[i], result[i+1] = result[i+1], result[i]\n    else:\n        result = lst\n    return result"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    \"\"\"\n    # check if three sides are given\n    if len(args)!= 3:\n        raise ValueError(\"triangle_area requires exactly 3 arguments\")\n    \n    # calculate the semi-perimeter\n    s = (a + b + c) / 2\n    \n    # check if three sides form a valid triangle\n    if s >= max(a, b, c):\n        # calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    \"\"\"\n    Returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n    \n    Examples:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n    \n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n    \n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n    \n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    \"\"\"\n    def is_palindrome(lst):\n        return lst == lst[::-1]\n    \n    def sum_elements(lst):\n        return sum(lst)\n    \n    if len(q) > w/2:\n        return False\n    elif not is_palindrome(q):\n        return False\n    else:\n        return sum_elements(q) <= w"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    n = len(arr)\n    # Create a copy of the original array\n    new_arr = list(arr)\n    \n    # Check if the array is already palindromic\n    if all(new_arr[i] == new_arr[-n+i] for i in range(n)):\n        return 0\n    \n    # Find the middle index of the array\n    mid = n // 2\n    \n    # If the middle element is odd, we need to swap it with its opposite end element\n    if new_arr[mid] % 2!= 0:\n        new_arr[mid], new_arr[-n+mid] = new_arr[-n+mid], new_arr[mid]\n        \n    # Otherwise, we need to move even elements towards the center until they become odd\n    else:\n        for i in range(mid - 1, -(n//2), -1):\n            if new_arr[i] % 2 == 0:\n                new_arr[i], new_arr[-n+i] = new_arr[:-1][-n+i], new_arr[i]\n                \n    # Check if the resulting array is palindromic\n    if all(new_arr[i] == new_arr[-n+i] for i in range(n)):\n        return int((n + 1) // 2)\n    else:\n        return int((n + 2) // 2)"}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    if len(lst1) < len(lst2):\n        return lst1\n    elif len(lst1) == len(lst2):\n        return lst1[:len(lst1)]\n    else:\n        return lst2[:min(len(lst1), len(lst2))]"}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n    if a < 100:\n        return all([i > 2 for i in [2, 3, 5] if i <= a]) or \\\n               all([i > 2 for i in [7, 11, 13] if i <= a]) or \\\n               all([i > 2 for i in [17, 19, 23] if i <= a]) or \\\n               all([i > 2 for i in [29, 31, 37] if i <= a]) or \\\n               all([i > 2 for i in [41, 43, 47] if i <= a]) or \\\n               all([i > 2 for i in [53, 59, 61] if i <= a]) or \\\n               all([i > 2 for i in [67, 71, 73] if i <= a]) or \\\n               all([i > 2 for i in [79, 83, 89] if i <= a]) or \\\n               all([i > 2 for i in [97, 101, 103] if i <= a]) or \\\n               all([i > 2 for i in [107, 109, 113] if i <= a]) or \\\n               all([i > 2 for i in [127, 131, 137] if i <= a]) or \\\n               all([i > 2 for i in [133, 137, 139] if i <= a]) or \\\n               all([i > 2 for i in [149, 151, 157] if i <= a]) or \\\n               all([i > 2 for i in [163, 167, 173] if i <= a]) or \\\n               all([i > 2 for i in [179, 181, 191] if i <= a]) or \\\n               all([i > 2 for i in [193, 197,"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    return x == int(n ** math.floor(math.log(x, n)))"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    return int(a**3) == a"}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    count = 0\n    for digit in num:\n        if str(int(digit)) in ['2', '3', '5', '7'] or str(int(digit)).isupper():\n            count += 1\n    return count"}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    if decimal == 0:\n        return \"db000000\"\n    elif decimal < 16:\n        binary = bin((decimal - 1)[2:])[2:] + \"0b\"\n    else:\n        while decimal > 0:\n            remainder = decimal % 4\n            binary += str(remainder) + \"0b\"\n            decimal //= 4\n    return \"db\" + binary[:-2] + \"db\""}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    # Check if the length of the string is at least 3\n    if len(s) < 3:\n        return False\n    \n    # Iterate over all groups of 3 consecutive letters\n    for i in range(len(s)-2):\n        if s[i] == s[i+1] == s[i+2]:\n            # If any group of 3 letters is repeated, then the string is not happy\n            return False\n        \n    # If we have iterated through all groups without finding a repeat, then the string is happy\n    return True"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    # Define a dictionary mapping gpa ranges to corresponding letter grades\n    grade_map = {\n        \"A+\": [4.0],\n        \"A\": [4.0, 3.7],\n        \"A-\": [4.0, 3.3],\n        \"B+\": [3.0, 2.7],\n        \"B\": [3.0, 2.3],\n        \"B-\": [3.0, 2.0],\n        \"C+\": [2.0, 1.7],\n        \"C\": [2.0, 1.3],\n        \"C-\": [2.0, 1.0],\n        \"D+\": [1.0, 0.7],\n        \"D\": [1.0, 0.0],\n        \"F\": [0.0]\n    }\n    \n    # Create a new empty list to store the resulting letter grades\n    result = []\n    \n    # Iterate through each grade in the input list\n    for grade in grades:\n        \n        # Find the range of gpas that correspond to this grade\n        if grade >= 4.0:\n            lower_bound = 4.0\n            upper_bound = float('inf')\n        elif grade >= 3.7:\n            lower_bound = 3.7\n            upper_bound = 4.0\n        elif grade >= 3.3:\n            lower_bound = 3.3\n            upper_bound = 3.7\n        elif grade >= 2.7:\n            lower_bound = 2.7\n            upper_bound = 3.0\n        elif grade >= 2.3:\n            lower_bound = 2.3\n            upper_bound = 2.7\n        elif grade >= 2.0:\n            lower_bound = 2.0\n            upper_bound = 2.3\n        elif grade >= 1.7:\n            lower_bound = 1.7\n            upper_bound = 2.0\n        elif grade >= 1.3:\n            lower_bound = 1.3\n            upper_bound"}
{"task_id": "HumanEval/82", "completion": "def prime_length(string):\n    return len([char for char in string if ord(char) < 128]) == 1 or all(ord(char)!= 0 for char in string)"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    # create a list of all n-digit positive integers\n    nums = [str(i) for i in range(10**n)]\n    \n    # count how many start or end with 1\n    count = sum([num[0] == '1' or num[-1] == '1' for num in nums])\n    \n    return count"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    # Convert N to binary and get the sum of its digits\n    binary_num = bin(N)[2:]\n    digit_sum = int(binary_num)\n    \n    # Pad the binary number with leading zeros if necessary\n    padded_binary = '0' * (3 - len(binary_num)) + binary_num\n    \n    # Return the padded binary number as a string\n    return padded_binary[::-1]"}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    return sum([num for num in lst if ((0 <= index % 2 == 1 or 3 <= index % 4 == 3), num))"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    # split the input string into words separated by space\n    words = s.split()\n    \n    # create a dictionary to store the sorted versions of each word\n    sorted_words = {}\n    \n    for i in range(len(words)):\n        # sort the letters of each word in ascending order\n        sorted_word = sorted(list(words[i]))\n        \n        if len(sorted_word) == len(set(sorted_word)):\n            # if there are no repeated letters, use the sorted word directly\n            sorted_words[words[i]] = sorted_word\n        else:\n            # if there are repeated letters, replace them with the first occurrence\n            sorted_word = [sorted_word[j] for j in range(min([i for i in enumerate(sorted_word)]))]\n            sorted_words[words[i]] = sorted_word\n    \n    # join the sorted words back into a single string\n    return''.join(sorted_words.get(w, w) for w in words)"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        if x in row:\n            for j, col in enumerate(row[:i+1]):\n                if col!= '':\n                    coords.append((i, len(row)-j))\n    coords.sort(key=lambda c: (c[0], -c[1]))\n    return coords"}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    sorted_array = sorted(array)\n    \n    # Check if sum(first index value, last index value) is odd or even\n    if len(sorted_array) % 2 == 0:\n        sorted_array.reverse()\n        \n    return sorted_array"}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n    # Define the alphabet\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    \n    # Rotate the alphabet by shifting each letter down by two multiplied to two places\n    rotated_alphabet = \"\"\n    for i in range(26):\n        if i < 10:\n            rotated_alphabet += chr((ord(alphabet[i]) - 97 * 2 + 2 * 2) % 26 + ord('a'))\n        else:\n            rotated_alphabet += chr((ord(alphabet[i]) - 97 * 2 + 2 * 2) % 26 + ord('A'))\n    \n    # Convert the input string to lowercase\n    s = s.lower()\n    \n    # Initialize an empty list to store the encrypted characters\n    encrypted_chars = []\n    \n    # Iterate over each character in the input string\n    for char in s:\n        \n        # If the character is already in the rotated alphabet, add it to the encrypted string\n        if char in rotated_alphabet:\n            encrypted_chars.append(char)\n            \n        # Otherwise, find the corresponding character in the original alphabet using the rotation formula\n        elif char >= 'a' and char <= 'z':\n            index = ((ord(char) - 97) - 2 * 2) % 26\n            encrypted_chars.append(chr(index + 97))\n                \n        # If the character is not in the alphabet or cannot be found using the rotation formula, return None\n        else:\n            return None\n    \n    # Join the encrypted characters into a single string and return it\n    return ''.join(encrypted_chars)"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    lst = sorted(set(lst)) # remove duplicates and sort the list\n    return lst[-2] if len(lst) > 1 else None"}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    sentences = S.split('.')\n    num_boreds = 0\n    for i in range(len(sentences)-1):\n        if sentences[i].strip().endswith('.'):\n            if sentences[i+1].startswith('I'):\n                num_boreds += 1\n    return num_boreds"}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    # Define a dictionary to map each vowel to its corresponding encoded value\n    vowels = {\n        'a': ord(chr(ord('A') + 1)),\n        'e': ord(chr(ord('E') + 1)),\n        'i': ord(chr(ord('I') + 1)),\n        'o': ord(chr(ord('O') + 1)),\n        'u': ord(chr(ord('U') + 1))\n    }\n    \n    # Convert all characters in the message to lowercase\n    message = message.lower()\n    \n    # Iterate over each character in the message\n    for index, char in enumerate(message):\n        \n        # Check if the current character is a vowel or a consonant\n        if char in ['a', 'e', 'i', 'o', 'u']:\n            # If the current character is a vowel, replace it with its encoded value\n            encoded_char = chr(vowels[char])\n            \n        else:\n            # Otherwise, keep the original character\n            encoded_char = char\n                \n        # Swap the case of the encoded character\n        if index % 2 == 0:\n            encoded_char = chr(ord(encoded_char) - 32)\n        \n        # Add the encoded character to the result string\n        result += encoded_char\n    \n    return result"}
{"task_id": "HumanEval/94", "completion": "def skjkasdkd(lst):\n    max_prime = None\n    max_sum = 0\n    \n    for num in lst:\n        if isinstance(num, int) and all([not str(i).isdigit() or i < 2 for i in str(num)]): # check if number is prime\n            if max_prime is None or num > max_prime: # update max prime if current number is larger than previous max prime\n                max_prime = num\n                max_sum = sum(str(max_prime)) # calculate sum of digits of max prime\n                \n    return max_sum"}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(dict):\n    # Check if the dictionary is empty\n    if len(dict) == 0:\n        return False\n    \n    # Iterate over each key and value pair in the dictionary\n    for key, val in dict.items():\n        \n        # If the key is not a string, return false immediately\n        if type(key)!= str:\n            return False\n        \n        # Check if the key is already converted to lowercase or uppercase\n        if key.islower() or key.isupper():\n            continue\n        \n        # Convert the key to lowercase or uppercase and compare it with the original key\n        if key.lower()!= key or key.upper()!= key:\n            return False\n        \n        # Recursively call the function on the nested dictionary\n        if isinstance(val, dict):\n            if not check_dict_case(val):\n                return False\n            \n    # All key/value pairs have been checked and none were found to violate the condition\n    return True"}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    primes = [i for i in range(2, n+1) if all([not isinstance(i%j, int) or j==2 for j in range(2, int(i**0.5)+1)])]\n    return list(set(primes[:min(len(primes), n)))[:n])"}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    if a == 0 or b == 0:\n        return 0\n    elif abs(a) > 10 or abs(b) > 10:\n        raise ValueError(\"Input must be less than or equal to 10\")\n    else:\n        product = 1\n        while a!= 0 and b!= 0:\n            if a % 10 < b % 10:\n                product *= 10\n            else:\n                product *= b % 10\n            a //= 10\n            b //= 10\n        return product"}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    return sum([1 for i, c in enumerate(s) if i % 2 == 0 and c.isupper()])"}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n    try:\n        # Convert string to float\n        num = float(value)\n        \n        # Round off to nearest integer\n        rounded_num = math.floor(num)\n        \n        # Check if equidistant from two integers\n        if abs(rounded_num - int(rounded_num)) == 0.5:\n            # Round away from zero\n            if rounded_num < 0:\n                return int(-1 * rounded_num)\n            else:\n                return int(rounded_num + 1)\n            \n        else:\n            return rounded_num\n                \n    except ValueError:\n        print(\"Invalid input: Please enter a valid number.\")"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    # base case for when n=0 or n==1\n    if n <= 1:\n        return []\n    \n    # recursive case for larger values of n\n    else:\n        # calculate the number of stones in the next level based on whether n is odd or even\n        num_stones = 2 * (n % 2 + 1)\n        \n        # recursively call make_a_pile() with n-1 and append the new level to the result from the previous recursion\n        result = make_a_pile(n-1) + [num_stones]\n        \n        # return the final result\n        return result"}
{"task_id": "HumanEval/101", "completion": "def words_string(s):\n    # Split the string by comma or space\n    words = s.split(\", \")\n    # Remove empty strings resulting from splitting by comma at end of sentence\n    words = [word for word in words if len(word) > 0]\n    # Return list of words\n    return words"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    if x <= y:\n        for i in range(2, y+1):\n            if i >= x and i % 2 == 0:\n                return i\n    else:\n        for i in range(y, x-1, -1):\n            if i >= x and i % 2 == 0:\n                return i\n    return -1"}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    else:\n        avg = round((n + m) / 2)\n        binary = bin(int(avg))[2:]\n        return binary"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    # Create an empty set to store unique digits\n    unique_digits = set()\n    \n    # Iterate through each element in the input list\n    for num in x:\n        # Check if the number has any even digits using modulo operator\n        if num % 2!= 0:\n            # Add the unique digits to the set\n            unique_digits.add(num)\n            \n    # Convert the set back to a list and sort it in ascending order\n    return sorted(list(unique_digits))"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    if len(arr) == 0:\n        return []\n    elif all([x >= 1 and x <= 9 for x in arr]):\n        sorted_arr = sorted(arr)\n        reversed_arr = list(reversed(sorted_arr))\n        result = [\"One\" if x == 1 else \"{}s\".format(str(x+1)) for x in reversed_arr]\n        return result\n    else:\n        return [\"Unknown\"]"}
{"task_id": "HumanEval/106", "completion": "def f(n):\n    result = []\n    for i in range(n+1):\n        if i % 2 == 0:\n            result.append(i*i*(i-1)*(i-2)*...*(1))\n        else:\n            result.append(sum([j for j in range(1, i+1)]))\n    return result"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    evens = sum([1 for i in range(1, n+1) if str(i) == str(i)[::-1]])\n    odds = sum([1 for i in range(1, n+1) if str(i)!= str(i)[::-1] and str(i)!= '0']) - sum([1 for i in range(1, n+1) if str(i) == str(i)[::-1]])\n    return (evens, odds)"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    return len([n for n in arr if sum(int(d) for d in str(abs(n))) > 0])"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    # Check if the input array is empty\n    if len(arr) == 0:\n        return True\n    \n    # Initialize variables to keep track of left and right boundaries\n    left = 0\n    right = len(arr)-1\n    \n    while left < right:\n        \n        # Check if the current element is greater than or equal to its next element\n        if arr[left] >= arr[right]:\n            # Swap the two elements\n            temp = arr[left]\n            arr[left] = arr[right]\n            arr[right] = temp\n            \n            # Move the left boundary towards the center\n            left += 1\n            \n        else:\n            # No swapping needed, move the right boundary towards the end\n            right -= 1\n    \n    # Return true if the array is now sorted in non-decreasing order\n    return arr == [max(arr)] * len(arr)"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    # Check if all elements of lst1 are odd\n    if sum([not x % 2 for x in lst1]) == len(lst1):\n        # Exchange elements until all elements of lst1 are even\n        while True:\n            for i in range(len(lst1)):\n                if lst1[i] % 2!= 0 and lst2[i % len(lst2)] % 2 == 0:\n                    lst1[i], lst2[i % len(lst2)] = lst2[i % len(lst2)], lst1[i]\n            if sum([x % 2 == 0 for x in lst1]) == len(lst1):\n                break\n        return \"YES\"\n    else:\n        return \"NO\""}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    words = test.split()\n    freq_dict = {}\n    max_freq = 0\n    for word in words:\n        if word.lower() in freq_dict:\n            freq_dict[word.lower()] += 1\n        else:\n            freq_dict[word.lower()] = 1\n        if freq_dict[word.lower()] > max_freq:\n            max_freq = freq_dict[word.lower()]\n    result = {max(key, default=None): value for key, value in sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)}\n    return result"}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    # Remove all characters in s that match any character in c\n    filtered_s = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = False\n    if len(filtered_s) > 1:\n        is_palindrome = filtered_s == filtered_s[::-1]\n        \n    return (filtered_s, is_palindrome)"}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        count = sum([int(d) % 2!= 0 for d in s])\n        result.append(\"the number of odd elements {} in the string {} of the input.\".format(count, i+1))\n    return result"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    if len(nums) == 0:\n        return float('inf') # infinity for empty arrays\n    \n    curr_sum = nums[0]\n    start_index = end_index = 0\n    curr_end = 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] > curr_sum + nums[i]:\n            curr_sum += nums[i]\n            start_index = i\n        elif nums[i] < curr_sum and i!= end_index:\n            curr_sum -= nums[i]\n            end_index = i\n        \n    if len(set(nums)) == 1:\n        return nums[start_index] * (len(nums) - start_index)\n    else:\n        return curr_sum"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    rows = len(grid)\n    cols = len(grid[0])\n    total_water = sum([sum([1 for x in row if x == 1]) for row in grid])\n    num_buckets = int(math.ceil(total_water / float(capacity)))\n    return num_buckets - 1"}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    def sort_helper(nums):\n        # count number of ones in binary representation\n        num_ones = bin(sum(int(digit)) for digit in str(num)[2:]).count('1')\n    \n        # sort by number of ones and then decimal value\n        return sorted(nums, key=lambda x: (-num_ones, abs(x)))\n    \n    if len(arr) > 1:\n        arr = [sort_helper([n])[0] for n in zip(*arr)]\n    else:\n        arr = [sort_helper([n])[0]] * len(arr)\n    \n    return arr"}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    # split the string into a list of words\n    words = s.split()\n    \n    # create an empty list to store selected words\n    selected_words = []\n    \n    for word in words:\n        # count the number of consonants in the word\n        num_consonants = sum([1 if c.isalpha() and c.istupper() else 0 for c in word])\n        \n        # check if the word has exactly n consonants\n        if num_consonants == n:\n            selected_words.append(word)\n            \n    return selected_words"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    # Initialize variables\n    left = -1\n    right = len(word) - 1\n    result = ''\n    # Check for vowels on the right side of the word\n    while right >= left + 1:\n        current = word[right]\n        if current.lower() in 'aeiou':\n            # If we found a vowel, check if it's the closest one\n            if abs(left - right) == 1:\n                result = current\n                break\n            elif abs(left - right) > 1:\n                # If there are multiple vowels closer to the left, keep searching\n                left += 1\n    return result"}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append(True)\n        elif s == ')':\n            if len(stack) > 0 and stack[-1] == True:\n                stack.pop(-1)\n            else:\n                return False\n        else:\n            return False\n    return not bool(stack)"}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    max_nums = []\n    for i in range(k):\n        if i < len(arr):\n            max_nums.append(max(arr[:i+1]))\n        else:\n            break\n    return max_nums"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    total = 0\n    for i in range(len(lst)):\n        if lst[i] % 2 == 1 and i % 2 == 0:\n            total += lst[i]\n    return total"}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    if len(arr) > 100 or k > len(arr) or k < 1:\n        raise ValueError(\"Invalid input\")\n    \n    result = 0\n    for i in range(min(k, len(arr))):\n        num = int(arr[i])\n        if 0 <= num <= 9:\n            result += num\n    \n    return result"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n    \n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n    \n    Note: \n        - Collatz(1) is [1].\n        - returned list sorted in increasing order.\n    \n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    def collatz(n):\n        if n == 0 or n == 1:\n            return []\n        elif n % 2 == 0:\n            return [n // 2] + collatz(n // 2)\n        else:\n            return [3 * n + 1] + collatz(3 * n + 1)\n    \n    odds = []\n    for num in collatz(n):\n        if num % 2!= 0:\n            odds.append(num)\n    odds.sort()\n    return odds"}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n    # Check if the date string is not empty\n    if len(date) == 0:\n        return False\n    \n    # Split the date string into day, month and year\n    parts = date.split(\"-\")\n    if len(parts)!= 3:\n        return false\n    \n    # Get the number of days from the input date string\n    num_days = int(parts[0]) * 10 + int(parts[1])\n    \n    # Check if the number of days is valid for the month and year\n    if ((num_days >= 1 and num_days <= 31) or (num_days >= 1 and num_days <= 30 and [1, 3, 5, 7, 8, 10, 12].count([int(month)-1]) > 0) or (num_days >= 1 and num_days <= 29 and [4, 6, 9, 11].count([int(month)-1]) > 0)) and \\\n       (int(parts[2]) >= 1 and int(parts[2]) <= 12)):\n        \n        return True\n    \n    else:\n        return False"}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    # Split on whitespace and comma\n    words = txt.split()\n    \n    # If there are no words, count the number of lower-case letters with odd order in the alphabet\n    if len(words) == 0:\n        num_odd_letters = sum([ord(c) % 2!= 0 for c in txt])\n        return int(num_odd_letters / 26)\n        \n    else:\n        return words"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    \"\"\"\n    Check if a given list contains only positive integers sorted in ascending order.\n    Return True if all elements are unique and sorted, else false.\n    \"\"\"\n    # Remove duplicates from the list\n    lst = list(set(lst))\n    \n    # Check if the list is sorted\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n    \n    return True"}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n    if len(interval1[0]) == len(interval2[0]):\n        for i in range(len(interval1)):\n            if interval1[i][0] <= interval2[i][1]:\n                return \"NO\"\n            elif interval1[i][1] >= interval2[i][0]:\n                return \"YES\"\n    else:\n        return \"NO\""}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    if len(arr) == 0:\n        return None\n    else:\n        result = 1\n        for num in arr:\n            sign = 1 if num >= 0 else -1 if num < 0 else 0\n            result *= sign\n        return abs(result)"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    # Find all valid neighbors for each cell\n    neighbors = [[0]*(k+1) for _ in range(len(grid))]\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            for di, ni in enumerate([(-1, 0), (0, -1), (1, 0), (-1, 1), (0, 1)]):\n                x, y = row + di, col + ni\n                if 0 <= x < len(grid) and 0 <= y < len(grid[x]) and x!= row and y!= col:\n                    neighbors[row][col] |= set((x, y))\n    \n    # Initialize visited set and parent dictionary\n    visited = {tuple(): None}\n    parents = {}\n    \n    def dfs(current):\n        nonlocal visited, parents\n        \n        # Check if already visited or at target depth\n        if tuple(current) in visited:\n            return []\n        elif k == 0:\n            return [current]\n        \n        # Try all valid neighbors\n        for ni, ni_value in enumerate(neighbors[current[0]][current[1]]):\n            next_row, next_col = ni_value\n            next_path = (current[:-1] + (next_row, next_col))\n            \n            # If next cell has not been visited yet, recurse\n            if next_path not in visited:\n                result = dfs(next_path)\n                if result:\n                    # Update parent dictionary\n                    parents[(tuple(result[-1]), next_row, next_col)] = current\n                    return result + [(current, )]\n    \n    # Start DFS from top left corner\n    queue = [(0, 0, k)]\n    while queue:\n        current = queue.popleft()\n        result = dfs(current)\n        if result:\n            return result\n    \n    # No solution found\n    return []"}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    if n == 0 or n == 1:\n        return [0, 1, 3]\n    elif n % 2 == 0:\n        return [0, 1, 3, 6, 10, 15, 21, 27, 35, 45]\n    else:\n        prev_tri = [0, 1, 3]\n        curr_tri = []\n        for i in range(2, n+1):\n            if i % 2!= 0:\n                curr_tri.append(prev_tri[i-1])\n                curr_tri.append(prev_tri[i-2])\n                curr_tri.append(prev_tri[i-3])\n            else:\n                curr_tri.append(prev_tri[i//2]) * 2\n        return curr_tri[:n+1]"}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n    # Initialize variable to store result\n    result = 1\n    \n    # Check each digit and multiply by 2 or 1 depending on whether it is odd or even\n    while n > 0:\n        digit = n % 10\n        if int(str(digit)[1]) % 2!= 0:\n            result *= 2\n        n //= 10\n        \n    return result"}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n    return not bool(stack)"}
{"task_id": "HumanEval/133", "completion": "def sum_squares(lst):\n    rounded_lst = [round(x).ceil() for x in lst]\n    squares = [x**2 for x in rounded_lst]\n    total_sum = sum(squares)\n    return total_sum"}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    # Remove all non-alphabetical characters from the end of the string\n    cleaned_string = txt.strip().replace(' ', '').replace('.', '')\n    \n    # Check if the length of the cleaned string is greater than 0\n    if len(cleaned_string) > 0:\n        # If the last character is a letter and there are no words after it, return true\n        if cleaned_string[-1].isalpha() and not re.search(r'\\w+$', cleaned_string):\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    max_index = len(arr) - 1\n    for i in range(max_index):\n        if arr[i] >= arr[i+1]:\n            break\n    else:\n        return max_index\n    return -1"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    if lst:\n        negatives = [x for x in lst if x < 0]\n        positives = [x for x in lst if x > 0]\n        if len(negatives) > 0:\n            a = max(negatives)\n        else:\n            a = None\n        if len(positives) > 0:\n            b = min(positives)\n        else:\n            b = None\n        return (a, b)\n    else:\n        return (None, None)"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    if isinstance(a, str) and ',' in a:\n        a = float(a.replace(',', ''))\n    elif isinstance(b, str) and ',' in b:\n        b = float(b.replace(',', ''))\n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return None"}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    if n < 0 or n > 12:\n        return False\n    elif n <= 4:\n        return True\n    else:\n        num_evens = [i for i in range(2, int(n/2)+1) if i % 2 == 0 and i <= n]\n        if len(num_evens) == 4:\n            return all([n - sum(num_evens[:j]) >= 0 for j in range(len(num_evens))])\n        else:\n            return False"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result"}
{"task_id": "HumanEval/140", "completion": "def fix_spaces(text):\n    # Replace single space by underscore\n    fixed = ''.replace(' ', '_')\n    \n    # Replace multiple spaces by dash\n    while len(fixed.split('_')) > 2:\n        fixed = fixed.replace('_', '-')\n    \n    return fixed"}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name):\n    if len([char for char in file_name if 0 <= ord(char) < 10]) > 3:\n        return \"No\"\n    elif not file_name.startswith(''.join(c for c in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')):\n        return \"No\"\n    else:\n        suffix = file_name.split('.')[1]\n        if suffix.lower() not in ['txt', 'exe', 'dll']:\n            return \"No\"\n        else:\n            return \"Yes\""}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    result = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            result += num ** 2\n        elif i % 4!= 0:\n            result += num ** 3\n    return result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    # split the sentence into individual words\n    words = sentence.split()\n    \n    # create an empty list to store the resulting words\n    result = []\n    \n    # iterate over each word in the sentence\n    for word in words:\n        \n        # check if the length of the word is a prime number\n        if all([not int(x) % i for i in range(2, abs(int(word)))]):\n            \n            # append the word to the result list\n            result.append(word)\n    \n    # join the resulting words back into a sentence\n    return''.join(result)"}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n    try:\n        result = float(x + '*' + str(n))\n        return int(result) == result\n    except ValueError:\n        return False"}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    def sort_by_sum_of_digits(num):\n        return sum(int(digit) for digit in str(num))\n    \n    sorted_nums = sorted(set([num for num in nums]))\n    result = [sorted_nums[i] for i in range(len(nums))]\n    return result"}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and ((num % 10) == 1 or (num % 10) == 3 or (num % 10) == 5 or (num % 10) == 7 or (num % 10) == 9):\n            count += 1\n    return count"}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    a = [i**2 - i + 1 for i in range(n)]\n    return sum([1 for i in range(len(a)) if len([j for j in range(i+1, len(a)) if a[i]*a[j]+a[k] % 3 == 0 for k in range(j+1, len(a))]) > 0])"}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    # Define a dictionary of planet names and their distances from the sun\n    planets = {\n        'Mercury': 0.39,\n        'Venus': 0.72,\n        'Earth': 1.00,\n        'Mars': 1.52,\n        'Jupiter': 5.20,\n        'Saturn': 9.58,\n        'Uranus': 19.18,\n        'Neptune': 30.07\n    }\n    \n    # Check if both planet names are valid\n    if planet1 not in planets and planet2 not in planets:\n        return ()\n    \n    # Calculate the distance from the sun for each planet\n    distances = [planets[name] - 0.5 * (planets[planet1] + planets[planet2]) for name in ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']]\n    \n    # Find indices of planets whose orbits are located between the orbit of planet1 and the orbit of planet2\n    indices = list(range(len(distances))).remove((planets['Mercury'], planets['Venus']) if planet1 == 'Mercury' else (planets[planet1], planets[planet2]))\n    \n    # Sort the remaining planets by the proximity to the sun\n    sorted_indices = sorted(indices, key=lambda i: abs(distances[i] - distances[-1]))\n    \n    # Return the sorted planet names\n    return [planets[sorted_indices[i]] for i in range(len(sorted_indices))]"}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    lst = [word for word in lst if len(word) % 2 == 0]\n    lst.sort()\n    return lst"}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n\ndef is_prime(num):\n    # check if num is divisible by any number between 2 and sqrt(num)\n    if num < 2 or all([i > 0 and num % i!= 0 for i in range(2, int(num**0.5)+1)]):\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    total = 0\n    for num in lst:\n        if isinstance(num, int) and abs(num) > 0:\n            if num % 2!= 0:\n                total += num ** 2\n    return total"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    correct = [0]*len(game)\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            correct[i] = 0\n        else:\n            correct[i] = abs(game[i] - guess[i])\n    return correct"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    # Create a dictionary to store the strength of each extension\n    strength = {}\n    \n    # Loop through each extension and calculate its strength\n    for ext in extensions:\n        cap = sum([ord(c) >= ord('A') and c.isupper() else False for c in ext])\n        sm = len([c.lower() for c in ext])\n        strength[ext] = cap - sm\n        \n    # Find the strongest extension\n    strongest_extension = max(strength, key=lambda x: strength[x])\n    \n    # Return the fully qualified name of the strongest extension\n    return f\"{class_name}.{strongest_extension}\""}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    for i in range(len(b)):\n        rotation = \"\"\n        for j in range(i, len(b)):\n            rotation += b[j]\n        if rotation in a:\n            return True\n    return False"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    count = {'even': 0, 'odd': 0}\n    while num > 0:\n        digit = num % 10\n        if int(str(digit)[1]) == 0 or int(str(digit)) == 0:\n            count['even'] += 1\n        else:\n            count['odd'] += 1\n        num //= 10\n    return count['even'], count['odd']"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    roman = {\n        1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", 10: \"X\",\n        40: \"XL\", 50: \"L\", 90: \"XC\", 100: \"C\"\n    }\n    \n    if number < 1 or number > 1000:\n        raise ValueError(\"Invalid input value\")\n    \n    result = \"\"\n    while number >= 1:\n        for i in range(len(roman)):\n            if number >= roman[i]:\n                break\n        else:\n            continue\n        result += roman[i]\n        number -= roman[i] * 10\n    \n    return result.lower()"}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n    \"\"\"\n    Checks whether a given set of side lengths forms a right-angled triangle.\n    Returns True if the triangle is a right-angled triangle, False otherwise.\n    Parameters:\n    - a (int): length of first side\n    - b (int): length of second side\n    - c (int): length of third side\n    \"\"\"\n    # Calculate the sum of squares of two shorter sides\n    short_side_sum = (b**2 + c**2)\n    # If the sum of squares of two shorter sides is equal to the square of the longest side, then it's a right-angled triangle\n    return abs(short_side_sum - a**2) < 1e-6"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    max_word = ''\n    for word in words:\n        if len(set([c for c in word])) > len(set([c for c in max_word])):\n            max_word = word\n    return max_word or sorted(words)[0]"}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    # check if there are enough remaining carrots for the needed amount\n    if remaining >= need:\n        # eat all remaining carrots and return the updated values\n        eaten = number + need\n        remaining -= need\n        return [eaten, remaining]\n    else:\n        # eat all remaining carrots and return the updated values\n        eaten = number + remaining\n        remaining = 0\n        return [eaten, remaining]"}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    # Check if the lengths of the lists are valid\n    if len(operator)!= len(operand)-1:\n        raise ValueError(\"Invalid input: operator and operand must have same length except for last element\")\n    \n    # Iterate over each pair of elements in the operator and operand lists\n    result = []\n    for i in range(len(operator)):\n        # Get the current operator and operand\n        op = operator[i]\n        x = operand[i]\n        \n        # Evaluate the expression using the current operator and operand\n        if op == \"+\":\n            y = operand[i+1]\n            result.append(x + y)\n        elif op == \"-\":\n            y = operand[i+1]\n            result.append(x - y)\n        elif op == \"*\":\n            y = operand[i+1]\n            result.append(x * y)\n        elif op == \"/\":\n            y = operand[i+1]\n            result.append(x / y)\n        elif op == \"**\":\n            y = operand[i+1]\n            result.append(x ** y)\n        else:\n            raise ValueError(\"Invalid operator: {}\".format(op))\n            \n    # Return the final result\n    return result"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    # Check if the first character of the string is a number\n    if ord(s[0]) >= 97 and ord(s[0]) <= 122:\n        # Reverse the string if it contains only numbers\n        return '#' + s[-1:] * len(s[:-1]) + '#'\n    \n    # Loop through each character in the string\n    for i in range(len(s)):\n        # Check if the current character is a letter\n        if ord(s[i]) >= 65 && ord(s[i]) <= 90 or ord(s[i]) >= 97 && ord(s[i]) <= 122:\n            # Reverse the case of the letter\n            if i == 0 or ord(s[i-1]) < 97 or ord(s[i-1]) > 122:\n                s = s[:i] + chr((ord(s[i]) - 32) % 2 + 32) + s[i+1:]\n            else:\n                s = s[:i] + chr((ord(s[i]) ^ 32) & ~32) + s[i+1:]\n        \n    # Return the resulting string\n    return s"}
{"task_id": "HumanEval/162", "completion": "def string_to_md5(text):\n    if text:\n        import hashlib\n        return hashlib.md5(text.encode()).hexdigest()\n    else:\n        return None"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    result = []\n    for i in range(a, b+1):\n        if i % 2 == 0:\n            result.append(i)\n    return sorted(result)"}
